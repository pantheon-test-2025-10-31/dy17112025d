/**
 * Edge Cache Clearer for CDN cache invalidation
 *
 * Provides functionality to clear edge CDN cache via proxy endpoint.
 * Implements non-blocking, error-resilient cache clearing to avoid
 * impacting main cache operations.
 */

export interface CacheClearResult {
    success: boolean;
    error?: string;
    statusCode?: number;
    duration?: number;
}

/**
 * Validates that the required environment variable is configured
 * @returns The proxy URL if valid
 * @throws Error if OUTBOUND_PROXY_ENDPOINT is not configured
 */
function buildProxyUrl(): string {
    const endpoint = process.env.OUTBOUND_PROXY_ENDPOINT;

    if (!endpoint) {
        throw new Error('OUTBOUND_PROXY_ENDPOINT environment variable is required for edge cache clearing');
    }

    return `http://${endpoint}/rest/v0alpha1/cache`;
}

/**
 * Creates an AbortController with timeout for fetch requests
 * @param timeoutMs Timeout in milliseconds
 * @returns AbortController that will abort after timeout
 */
function createTimeoutController(timeoutMs: number): AbortController {
    const controller = new AbortController();
    setTimeout(() => controller.abort(), timeoutMs);
    return controller;
}

/**
 * Handles HTTP response and extracts error details
 * @param response Fetch response object
 * @returns Error message if response is not ok
 */
async function extractResponseError(response: Response): Promise<string> {
    try {
        const errorText = await response.text();
        return errorText || 'Unknown error';
    } catch {
        return 'Unknown error';
    }
}

/**
 * Creates a standardized error result
 * @param error Error message
 * @param duration Operation duration in ms
 * @param statusCode Optional HTTP status code
 * @returns CacheClearResult with error details
 */
function createErrorResult(error: string, duration: number, statusCode?: number): CacheClearResult {
    return {
        success: false,
        error,
        duration,
        statusCode
    };
}

/**
 * Creates a standardized success result
 * @param duration Operation duration in ms
 * @param statusCode HTTP status code
 * @returns CacheClearResult with success details
 */
function createSuccessResult(duration: number, statusCode: number): CacheClearResult {
    return {
        success: true,
        statusCode,
        duration
    };
}

/**
 * Performs the actual HTTP DELETE request to clear edge cache
 * @param proxyUrl The proxy endpoint URL
 * @param controller AbortController for timeout
 * @returns Promise resolving to fetch Response
 */
async function performCacheDeleteRequest(proxyUrl: string, controller: AbortController): Promise<Response> {
    return fetch(proxyUrl, {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json',
        },
        // signal: controller.signal
    });
}

export default class EdgeCacheClear {
    private proxyUrl: string;

    constructor() {
        this.proxyUrl = buildProxyUrl();
    }

    /**
     * Clears edge CDN cache via proxy endpoint
     * Implements timeout and comprehensive error handling
     * @returns Promise resolving to cache clear result
     */
    async nukeCache(): Promise<CacheClearResult> {
        const startTime = Date.now();

        try {
            console.log(`[EdgeCacheClear] Attempting to clear edge cache via: ${this.proxyUrl}`);

            const controller = createTimeoutController(10000);
            const response = await performCacheDeleteRequest(this.proxyUrl, controller);

            const duration = Date.now() - startTime;

            if (!response.ok) {
                const errorText = await extractResponseError(response);
                console.error(`[EdgeCacheClear] HTTP Error ${response.status}: ${errorText}`);

                return createErrorResult(
                    `HTTP ${response.status}: ${errorText}`,
                    duration,
                    response.status
                );
            }

            console.log(`[EdgeCacheClear] Successfully cleared edge cache in ${duration}ms`);
            return createSuccessResult(duration, response.status);

        } catch (error) {
            const duration = Date.now() - startTime;
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';

            console.error(`[EdgeCacheClear] Failed to clear edge cache:`, error);
            return createErrorResult(errorMessage, duration);
        }
    }

    /**
     * Non-blocking version of cache clearing for background execution
     * Logs results but doesn't throw errors
     * @param context Description of what triggered this clear operation
     */
    async nukeCacheInBackground(context: string): Promise<void> {
        try {
            const result = await this.nukeCache();

            if (result.success) {
                console.log(`[EdgeCacheClear] Background clear successful for ${context} (${result.duration}ms)`);
            } else {
                console.warn(`[EdgeCacheClear] Background clear failed for ${context}: ${result.error} (${result.duration}ms)`);
            }
        } catch (error) {
            console.error(`[EdgeCacheClear] Background clear error for ${context}:`, error);
        }
    }
}